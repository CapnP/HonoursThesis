%%
%% Template chap1.tex
%%

\chapter{Background}
\label{cha:background}

\section{First-Order Logic Terms and Notation}
\label{sec:senfol}

This thesis focuses around the extension of \beagle, a \emph{first-order logic} (FOL) theorem prover.
In order to understand beagle's purpose and functions a basic understanding of the FOL logical system
is required. This section provides a rudimentary overview of FOL syntax and uses;
but also includes an explanation of any specialised terms and notation used throughout the paper.

\subsection{FOL basics}
\notes{
Should contain
\begin{itemize}
\item Variables
\item Symbols
\item Predicates
\item Quantifiers
\item Notion of soundness and completeness
\item Description of a 'calculus'
\end{itemize}}

\subsection{Logic Terminology used in this Paper}

\subsubsection{Positions}

\subsubsection{Substitution}

\subsection{Calculi and FOL problems}

\subsection{The Superposition Calculus}



\begin{itemize}
\item Positions
\end{itemize}

\section{Automated Reasoning and Theorem Proving}
\label{sec:proving}

Automated Reasoning is a rapidly growing field of research where computer programs
are used to solve problems stated in first order logic statements or other formal logics.

Some existing resolution theorem provers include:

\subsection{SPASS}
\cite{spass}

\subsection{Vampire}
\cite{vampire}

\subsection{E}
\cite{eprover}

\section{Term Indexing}
\label{sec:indexing}

Term indexing is a technique used to better locate logical terms which match rules
in a prover's calculus.

\subsubsection{Top Symbol Hashing}

\subsubsection{Discriminant Trees}


\section{Fingerprint Indexing}
\label{sec:fingerprint}

\emph{Fingerprint Indexing} is a recent technique developed by \citeN{shulz12}, the creator
of the E prover. It works by computing a \emph{fingerprint} for each logic term;
which can compared for unification or match compatibility.
It is a \emph{non-perfect} technique in that compatible fingerprints will not
always imply that the associated terms successfully unify/match. The technique
makes up for this by being adjustable to arbitrary levels of precision; ranging between
what essentially amounts to Top-Symbol Hashing (See section \ref{sec:indexing})
to comprehensive, but slow to compute, term comparisons.

\subsection{Term Fingerprints}

\begin{table}[h]\begin{center}
  \caption{Fingerprint matches for Unification \protect\cite[p6]{shulz12}}
  \label{tab:unif}
  \begin{tabular}{| c || c | c | c | c | c |}
  \hline
           &  $f_1$      &  $f_2$      &  \textbf{A} &  \textbf{B} &  \textbf{N} \\ \hline \hline
  $f_1$    &  \compY &  \compN &  \compY &  \compY &  \compN \\ 
  $f_2$    &  \compN &  \compY &  \compY &  \compY &  \compN \\ 
\textbf{A} &  \compY &  \compY &  \compY &  \compY &  \compN \\
\textbf{B} &  \compY &  \compY &  \compY &  \compY &  \compY \\ 
\textbf{N} &  \compN &  \compN &  \compN &  \compY &  \compY \\ \hline
  \end{tabular}
\end{center}\end{table}

\begin{table}[h]\begin{center}
  \caption{Fingerprint matches for Matching \protect\cite[p6]{shulz12}}
  \begin{tabular}{| c || c | c | c | c | c |}
  \hline
           &  $f_1$      &  $f_2$      &  \textbf{A} &  \textbf{B} &  \textbf{N} \\ \hline \hline
  $f_1$    &  \compY &  \compN &  \compN &  \compN &  \compN \\ 
  $f_2$    &  \compN &  \compY &  \compN &  \compN &  \compN \\ 
\textbf{A} &  \compY &  \compY &  \compY &  \compN &  \compN \\
\textbf{B} &  \compY &  \compY &  \compY &  \compY &  \compY \\ 
\textbf{N} &  \compN &  \compN &  \compN &  \compN &  \compY \\ \hline
  \end{tabular}
\end{center}\end{table}

\subsection{The Fingerprint Index}

\subsection{Position Variants}

\section{The \Beagle\ Theorem Prover}
\label{sec:beagle}
%Beagle will already be discussed in intro.
%Here we can be more technical due to background info

The core implementation of {\beagle} was developed by Peter Baumgartner et al. of NICTA.
Its purpose was to demonstrate the capabilities of the \emph{\HSWA};
which allows the incorporation of prior knowledge via `background reasoning' modules.

\subsection{Weak Abstraction}

\subsection{Base Inference System}

The inference rules for the {\HSWA} are essentially identical to the standard 
superposition calculus; except for the fact that they come with additional
conditions to accommodate background reasoning.

\[ \textbf{Positive Superposition}\quad\quad \frac{l \approx r \lor C\quad \quad s[u] \approx t \lor D}{\text{abstr}((s[r] \approx t \lor C \lor D)\sigma)} \]

\[ \textbf{Negative Superposition}\quad\quad \frac{l \approx r \lor C\quad \quad s[u] \not\approx t \lor D}{\text{abstr}((s[r] \not\approx t \lor C \lor D)\sigma)} \]

\subsection{\Beagle's Shortcomings}



\section{Tools Used}

\subsection{Scala}
\label{sec:scala}

As mentioned above \beagle\ is written in \emph{Scala}, the Scalable Language. Scala
is a functional language and may be confusing to those who are not familiar with the
functional programming paradigm. This thesis will contain occasional snippets of
Scala code; but note that any snippets used will be accompanied by an explanation
and in general an understanding of Scala/functional programming is not required.

\subsection{VisualVM}

\subsection{Eclipse}
Integration with Scala and ScalaTest

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
