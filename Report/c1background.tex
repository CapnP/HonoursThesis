%%
%% Template chap1.tex
%%

\chapter{Background}
\label{cha:background}

\section{First-Order Logic Terms and Notation}
\label{sec:senfol}

This thesis focuses around the extension of \beagle, a \emph{first-order logic} (FOL) theorem prover.
In order to understand beagle's purpose and functions a basic understanding of the FOL logical system
is required. This section provides a rudimentary overview of FOL syntax and uses;
but also includes an explanation of any specialised terms and notation used throughout the paper.

\subsection{FOL basics}
\notes{
Should contain
\begin{itemize}
\item Variables
\item Symbols
\item Predicates
\item Quantifiers
\item Notion of soundness and completeness
\item Description of a 'calculus'
\end{itemize}}

\subsection{Logic Terminology used in this Paper}
\label{sec:terminology}

\subsubsection{Positions}
Many concepts in this paper require the ability to precisely point out a specific
subterm/symbol within a term. Thus we introduce a syntax for term \emph{positions}.
This sort of syntax is a standard concept in the field of logic; but here we
will be using a slightly extended syntax as we will have need to reference
positions which do not exist \cite{shulz12}.

A \emph{position} is given as a (possibly empty) list of natural numbers.
$t|_p$ refers to the subterm of $t$ at position $p$.
The empty position, $t|_\epsilon$, refers to the outermost function or variable
of a term. A position $t|_n$ refers to the $n^{th}$ argument of the outermost function,
$t|_{n.m}$ to the $m^{th}$ argument of that $n^{th}$ argument; and so on. If the position
does not exist in the term we return Nil. Consider the following example:
\[t = f(a, g(a, x, y), b)\]
\[t|_{\epsilon} = f \quad\quad t|_{1} = a \quad\quad  t|_{2.2} = x \quad\quad  t|_{2.3.3} = \text{Nil} \quad\quad  t|_{3.2} = \text{Nil}\]

\subsubsection{Substitution}

\subsection{Popular Problems in First Order Logic}

\subsection{The Superposition Calculus}
\label{sec:supcalc}

Based on resolution, exists to allow ... \cite{supcalc}

\begin{align*}
\textbf{Positive Superposition} &&& \frac{l \approx r \lor C\quad \quad s[u] \approx t \lor D}{(s[r] \approx t \lor C \lor D)\sigma}
\intertext{\tcent{Where $\sigma = $ mgu $(l,u)$, and $u$ is not a variable}}
\textbf{Negative Superposition} &&& \frac{l \approx r \lor C\quad \quad s[u] \not\approx t \lor D}{(s[r] \not\approx t \lor C \lor D)\sigma}
\intertext{\tcent{Where $\sigma = $ mgu $(l,u)$, and $u$ is not a variable}}
\textbf{Equality Resolution}    &&& \frac{s \not\approx t \lor C}{C\sigma}
\intertext{\tcent{Where $\sigma = $ mgu $(s,t)$}}
\textbf{Equality Factoring}     &&& \frac{l \approx r \lor s \approx t \lor C}{(l \approx t \lor r \not \approx t \lor C)\sigma}
\intertext{\tcent{Where $\sigma = $ mgu $(s,l)$}}
\end{align*}
These rules

\section{Automated Reasoning and Theorem Proving}
\label{sec:proving}

Automated Reasoning is a rapidly growing field of research where computer programs
are used to solve problems stated in first order logic statements or other formal logics.

Some existing resolution theorem provers include:

\subsection{SPASS}
\cite{spass}

\subsection{Vampire}
\cite{vampire}

\subsection{E}
\cite{eprover}

\section{Term Indexing}
\label{sec:indexing}

Term indexing is a technique used to better locate logical terms which match rules
in a prover's calculus.

\subsubsection{Top Symbol Hashing}

\subsubsection{Discriminant Trees}


\section{Fingerprint Indexing}
\label{sec:fingerprint}

\emph{Fingerprint Indexing} is a recent technique developed by \citeN{shulz12}, the creator
of the E prover. It works by computing a \emph{fingerprint} for each logic term;
which can compared for unification or match compatibility.
It is a \emph{non-perfect} technique in that compatible fingerprints will not
always imply that the associated terms successfully unify/match. The technique
makes up for this by being adjustable to arbitrary levels of precision; ranging between
what essentially amounts to Top-Symbol Hashing (See section \ref{sec:indexing})
to comprehensive, but slow to compute, term comparisons.

\subsection{Term Fingerprints}
\label{sec:fingerprints}

A term's \emph{fingerprint} is a list of \emph{fingerprint features} which
indicate what the term looks like at a given position. The 4 possible
fingerprint features are:
\begin{itemize}
\item \textbf{A}: the term has a variable at the position.
\item $f$ (any function or constant in the current system): This
feature indicates that $f$ is at the given position in the term.
\item \textbf{B}: the position does not exist in the term, but can be created
by expanding a variable via substitution.
\item \textbf{N}: the position does not exist and cannot be created.
\end{itemize}
Term fingerprints are computed with respect to a list of positions. We do this by simply
computing which feature exists at each position. We will now revisit the example from
the explanation of term positions (Section \label{sec:terminology}) to show
the computation of a fingerprint. In the example $\{f,g\}$ are functions, $\{a,b\}$ are
constants and $\{x,y\}$ are variables.
\[t = f(a, g(a, x, y), b)\]
\[\text{positions} = [\epsilon, 1, 2.2, 2.3.3, 3.2] \]
\[t|_{\epsilon} = f \quad\quad t|_{1} = a \quad\quad  t|_{2.2} = x \quad\quad  t|_{2.3.3} = \text{Nil} \quad\quad  t|_{3.2} = \text{Nil}\]
\[\fp(t, \text{positions}) = [f, a, \textbf{A}, \textbf{B}, \textbf{N}] \]

\begin{table}[h]\begin{center}
  \caption{Fingerprint Feature compare table for Unification \protect\cite[p6]{shulz12}}
  \label{tab:unif}
  \begin{tabular}{| c || c | c | c | c | c |}
  \hline
           &  $f_1$      &  $f_2$      &  \textbf{A} &  \textbf{B} &  \textbf{N} \\ \hline \hline
  $f_1$    &  \compY &  \compN &  \compY &  \compY &  \compN \\ 
  $f_2$    &  \compN &  \compY &  \compY &  \compY &  \compN \\ 
\textbf{A} &  \compY &  \compY &  \compY &  \compY &  \compN \\
\textbf{B} &  \compY &  \compY &  \compY &  \compY &  \compY \\ 
\textbf{N} &  \compN &  \compN &  \compN &  \compY &  \compY \\ \hline
  \end{tabular}
\end{center}\end{table}

\begin{table}[h]\begin{center}
  \caption{Fingerprint Feature compare table for Matching \protect\cite[p6]{shulz12}}
  \begin{tabular}{| c || c | c | c | c | c |}
  \hline
           &  $f_1$      &  $f_2$      &  \textbf{A} &  \textbf{B} &  \textbf{N} \\ \hline \hline
  $f_1$    &  \compY &  \compN &  \compN &  \compN &  \compN \\ 
  $f_2$    &  \compN &  \compY &  \compN &  \compN &  \compN \\ 
\textbf{A} &  \compY &  \compY &  \compY &  \compN &  \compN \\
\textbf{B} &  \compY &  \compY &  \compY &  \compY &  \compY \\ 
\textbf{N} &  \compN &  \compN &  \compN &  \compN &  \compY \\ \hline
  \end{tabular}
\end{center}\end{table}

\subsection{The Fingerprint Index}

\subsection{Position Variants}

\section{The \Beagle\ Theorem Prover}
\label{sec:beagle}
%Beagle will already be discussed in intro.
%Here we can be more technical due to background info

The core implementation of {\beagle} was developed by Peter Baumgartner et al. of NICTA.
Its purpose was to demonstrate the capabilities of the \emph{\HSWAC};
which allows the incorporation of prior knowledge via `background reasoning' modules. \cite{baum13}

\subsection{Hierarchic Reasoning}
The logical calculus behind {\beagle} is far from the first occurrence of using a hierarchy for
logical reasoning. A calculus was developed by \citeN{bach94} to take advantage
of this technique. Note that Waldmann continued on to co-write the paper outlining
{\HSWA} \cite{baum13}.

The hierarchic reasoning system also involves an ordering on terms.

\subsection{Weak Abstraction}
In order to keep the \emph{foreground} and \emph{background} reasoning
systems segregated it is necessary to clearly split a clause into its foreground
and background parts. This is where the process of \emph{weak abstraction} comes in.

In logics with equality there is a general process known as \emph{abstraction},
where a subterm within a clause may be replaced by a fresh variable.
\[\textbf{Abstraction}\quad\quad \frac{C[t]}{t\not\approx X \lor C[X]}\]
This rule can be used to introduce new abstraction variables to take the place
of any background subterms. \citeN{bach94} extended this form of derivation to what they called \emph{full-abstraction},
where abstraction is performed exhaustively until no literal contains both foreground
and background operators.

In their recent paper however, \citeN{baum13} discovered that the process 
of full abstraction can destroy completeness. They then go on to propose a new
variety of abstraction where only \emph{maximal background subterms which are
neither domain elements nor variables} are abstracted. Abstracted terms are replaced
with abstraction variables in the case of pure background terms, or ordinary variables
in the case of impure background terms. See the paper itself for weak abstraction
examples and details of how this process affects completeness.

\subsection{Rule Based Inference System}
\label{sec:calc}

The base inference rules for the {\HSWAC} are essentially identical to the standard 
superposition calculus; except for the fact that they come with many additional
conditions to accommodate background reasoning. These conditions include respecting
clause orderings and disallowing the use of pure background terms.

The results of any inferences must also have weak abstraction performed on them. This
ensures that we only ever have weakly abstracted terms in our logical system. The
base inference rules follow, taken directly from Section 6 of the {\HSWA} paper \cite{baum13}.
See Section \ref{sec:supcalc} to compare these rules to the original
superposition calculus.

\begin{align*}
\textbf{Positive Superposition} &&& \frac{l \approx r \lor C\quad \quad s[u] \approx t \lor D}{\text{abstr}((s[r] \approx t \lor C \lor D)\sigma)} 
\intertext{\tcent{Where
(i) $\sigma = $ simple mgu $(l,u)$,
(ii) $u$ is not a variable,
(iii) $r\sigma \not\succeq l\sigma$,
(iv) $t\sigma \not\succeq s\sigma$,\\
(v) $l$ and $u$ are not pure background terms,
(vi) $(l \approx r)\sigma$ is strictly maximal in $(l \approx r \lor C)\sigma$, and
(vii) $(s \approx t)\sigma$ is strictly maximal in $(s \approx t \lor D)\sigma$ }}
\textbf{Negative Superposition} &&& \frac{l \approx r \lor C\quad \quad s[u] \not\approx t \lor D}{\text{abstr}((s[r] \not\approx t \lor C \lor D)\sigma)}
\intertext{\tcent{Where 
(i) $\sigma = $ simple mgu $(l,u)$,
(ii) $u$ is not a variable,
(iii) $r\sigma \not\succeq l\sigma$,
(iv) $t\sigma \not\succeq s\sigma$,\\
(v) $l$ and $u$ are not pure background terms,
(vi) $(l \approx r)\sigma$ is strictly maximal in $(l \approx r \lor C)\sigma$, and
(vii) $(s \not\approx t)\sigma$ is strictly maximal in $(s \not\approx t \lor D)\sigma$ }}
\textbf{Equality Resolution}    &&& \frac{s \not\approx t \lor C}{\text{abstr}(C\sigma)}
\intertext{\tcent{Where 
(i) $\sigma = $ simple mgu $(s,t)$,
(ii) $s$ and $t$ are not pure background terms,\\ and
(iii) $(s \not\approx t)\sigma$ is strictly maximal in $(s \not\approx t \lor C)\sigma$}}
\textbf{Equality Factoring}     &&& \frac{l \approx r \lor s \approx t \lor C}{\text{abstr}((l \approx t \lor r \not \approx t \lor C)\sigma)}
\intertext{\tcent{Where 
(i) $\sigma = $ simple mgu $(l,u)$,
(ii) $r\sigma \not\succeq l\sigma$,
(iii) $t\sigma \not\succeq s\sigma$,
(iv) $l$ and $s$ are not pure background terms, and
(v) $(l \approx r)\sigma$ is strictly maximal in $(l \approx r \lor s \approx t \lor C)\sigma$}}
\end{align*}
Note the use of a slightly different unification operator, for \emph{simple} mgus.
This operator only produces mgus where abstraction variables are mapped
to pure background terms.

\subsection{\Beagle's Shortcomings}



\section{Tools Used}

\subsection{Scala}
\label{sec:scala}

\Beagle\ is written in \emph{Scala}, the Scalable Language. Scala
is a functional language and may be confusing to those who are not familiar with the
functional programming paradigm. This thesis will contain occasional snippets of
Scala code; but note that any snippets used will be accompanied by an explanation
and in general an understanding of Scala/functional programming is not required.

\subsection{VisualVM}

\subsection{Eclipse}
Integration with Scala and ScalaTest

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
