%%
%% Template chap2.tex
%%

\chapter{Implementing Fingerprint Indexing}
\label{cha:method}

\section{Structure of \beagle}
\label{sec:initial}

To be able to make any significant contribution to the \beagle  project, I first
had to gain a solid understanding of the existing Scala codebase.

*Figure of Clause/Expression syntax tree*

Describe main inference loop

Refer to results for instrumentation; showing what may be improved with indexing.

\section{Implementing Fingerprint Indexing}
\label{sec:initial}

The first step in adding Fingerprint Indexing to \beagle is creating the indexer
itself; a Scala class which will manage the index and provide functions for adding
to/retreiving from the Index. 

To compare two fingerprints with each other we look at them side-by-side and check
that each position shows a Y in the Fingerprint unifcation table. 
\begin{listing}[H]
\begin{scalacode}
 /** Check two Fingerprint features for compatibility based
   * on the unification table (See page 6 of [Shulz 2012]).
   * This table is reduced to 4 cases:
   *  - True if Features are equal,
   *  - True if at least one Feature is B,
   *  - True if at least one Feature is A; but no Ns,
   *  - False otherwise  */
  def compareFeaturesForUnification
         (a:FPFeature, b:FPFeature) : Boolean =
  (a == b) || 
  (Set(a,b) match {
    case x if (x contains FPB) => true
    case x if (x contains FPA) => !(x contains FPN)
    case _ => false})
\end{scalacode}
\caption{Scala implementation of the Fingerprint unification table. \protect\cite[p6]{shulz12}}
\label{lst:unitable}
\end{listing}

The following block of Scala code extracts a single Fingerprint Feature from
a Term at the given position.
\begin{listing}[H]
\begin{scalacode}
 /** Extract the operator at position pos. Note that matching Var
   * and Funterm is an exhaustive pattern for Term. */
  def extractFeature(term: Term, pos: Position) : FPFeature = pos match {
    case Nil     => term match {
      case t:FunTerm => FPF(t.op) // Found function symbol, return it
      case t:Var     => FPA       // Found variable, return A
    }
    case p :: ps => term match {
      case t:FunTerm => try   {extractFeature(t.args(p), ps) }
                        //Attempted to index non-existent position, return N
                        catch {case e:IndexOutOfBoundsException => FPN}
      // Found variable BEFORE end of position, return B
      case t:Var     => FPB 
    }
  }
\end{scalacode}
\caption{Scala code to extract fingerprint features for matching.}
\label{lst:posextract}
\end{listing}

\section{Adding Indexing to \Beagle}

\subsection{Refactoring Current Implementation}

Actually making use of our indexer class will require significant modification
to \beagle's structure and proving sequence.

Refer to class and flow diagrams from \ref{sec:initial}

\subsection{Initial Problems}

\section{Tailoring to \Beagle's Heirachic Superposition with Weak Abstraction Calculus}
\label{sec:tailored}

\subsection{Foreground and Background Terms}

In the Heirachic Superposition with Weak Abstraction Calculus all terms have 
a concept of being 'Foreground' or 'Background'.

*Extended feature match table and code*
\begin{table}[h]\begin{center}
  \caption{Extended Fingerprint matches for Unification}
  \begin{tabular}{| c || c | c | c | c | c || c | c | c | c | c |}
  \hline
               &  $f_1$      &  $f_2$      &  \textbf{A} &  \textbf{B} &  \textbf{N} & PBG $f_1$  & PBG $f_2$      & PBG \textbf{A} & PBG \textbf{B} & PBG \textbf{N} \\ \hline \hline
  $f_1$        &  \compY &  \compN &  \compY &  \compY &  \compN \\ 
  $f_2$        &  \compN &  \compY &  \compY &  \compY &  \compN \\ 
\textbf{A}     &  \compY &  \compY &  \compY &  \compY &  \compN \\
\textbf{B}     &  \compY &  \compY &  \compY &  \compY &  \compY \\ 
\textbf{N}    &  \compN &  \compN &  \compN &  \compY &  \compY \\ \hline \hline
PBG   $f_1$    &  \compY &  \compN &  \compY &  \compY &  \compN \\ 
PBG   $f_2$    &  \compN &  \compY &  \compY &  \compY &  \compN \\ 
PBG \textbf{A} &  \compY &  \compY &  \compY &  \compY &  \compN \\
PBG \textbf{B} &  \compY &  \compY &  \compY &  \compY &  \compY \\ 
PBG \textbf{N} &  \compN &  \compN &  \compN &  \compY &  \compY \\\hline
  \end{tabular}
\end{center}\end{table}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
