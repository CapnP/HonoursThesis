%%
%% Template chap2.tex
%%

\chapter{Implementing Fingerprint Indexing}
\label{cha:method}

\section{Structure of \beagle}
\label{sec:initial}

To be able to make any significant contribution to the \beagle  project, I first
had to gain a solid understanding of the existing Scala codebase.

*Figure of Clause/Expression syntax tree*

Describe main inference loop

Refer to results for instrumentation; showing what may be improved with indexing.

\section{Implementing Fingerprint Indexing}
\label{sec:initial}

The first step in adding Fingerprint Indexing to \beagle is creating the indexer
itself; a Scala class which will manage the index and provide functions for adding
to/retreiving from the Index. 

To compare two fingerprints with each other we look at them side-by-side and check
that each position shows a Y in the Fingerprint unifcation table. 
\begin{listing}[H]
\begin{scalacode}
 /** Check two Fingerprint features for compatibility based
   * on the unification table (See page 6 of [Shulz 2012]).
   * This table is reduced to 4 cases:
   *  - True if Features are equal,
   *  - True if at least one Feature is B,
   *  - True if at least one Feature is A; but no Ns,
   *  - False otherwise  */
  def compareFeaturesForUnification
         (a:FPFeature, b:FPFeature) : Boolean =
  (a == b) || 
  (Set(a,b) match {
    case x if (x contains FPB) => true
    case x if (x contains FPA) => !(x contains FPN)
    case _ => false})
\end{scalacode}
\caption{Scala implementation of the Fingerprint unification table. \protect\cite[p6]{shulz12}}
\label{lst:unitable}
\end{listing}

The following block of Scala code extracts a single Fingerprint Feature from
a Term at the given position.
\begin{listing}[H]
\begin{scalacode}
 /** Extract the operator at position pos. Note that matching Var
   * and Funterm is an exhaustive pattern for Term. */
  def extractFeature(term: Term, pos: Position) : FPFeature = pos match {
    case Nil     => term match {
      case t:FunTerm => FPF(t.op) // Found function symbol, return it
      case t:Var     => FPA       // Found variable, return A
    }
    case p :: ps => term match {
      case t:FunTerm => try   {extractFeature(t.args(p), ps) }
                        //Attempted to index non-existent position, return N
                        catch {case e:IndexOutOfBoundsException => FPN}
      // Found variable BEFORE end of position, return B
      case t:Var     => FPB 
    }
  }
\end{scalacode}
\caption{Scala code to extract fingerprint features for matching.}
\label{lst:posextract}
\end{listing}

\section{Adding Indexing to \Beagle}

\subsection{Refactoring Current Implementation}

Actually making use of our indexer class will require significant modification
to \beagle's structure and proving sequence.

Refer to class and flow diagrams from \ref{sec:initial}

\subsection{Initial Problems}

\section{Tailoring to \Beagle's Heirachic Superposition with Weak Abstraction Calculus}
\label{sec:tailored}

\subsection{Foreground and Background Terms}

In the Heirachic Superposition with Weak Abstraction Calculus all terms have 
a concept of being 'Foreground' or 'Background'. In Section \ref{sec:beagle} we
discussed this concept; referring to it as the \emph{layer} of a term. It is
worht noting at this stage that computing the layer of a term is cheap (or rather,
zero, as it is computed on the fly during term generation and stored for later use).

We introduce two new fingerprint features: B+ and A+ for `background' or `abstraction' variables.
Note that here we may use the foregroundedness of the entire subterm rather than just that
of the current position.

The layeredness of function symbols is also relevant to our comparison.
$f$+ in the following table signifies a position where the entire subterm from this position downwards
is `pure background'. Keep in mind that A+ and B+ differ from this definition slightly.

We present here the (rather large) extended unification table with no justification.
Refer to the original unification table (Table \ref{tab:unif}) for an in depth
explanation of how this table should be interpreted \cite{shulz12}.

\begin{table}[h]\begin{center}
  \caption{Fingerprint matches for unification; extended by considering term layers.}
  \begin{tabular}{| c || c | c | c | c | c || c | c | c | c |}
  \hline
            &  $f_1$  &  $f_2$  &  \textbf{A} &  \textbf{B} &  \textbf{N} & $f_1$+  & $f_2$+  & \textbf{A}+ & \textbf{B}+ \\ \hline \hline
  $f_1$     &  \compY &  \compN &  \compY     &  \compY     &  \compN     & \compN  & \compN  & \compN      & \compN      \\ 
  $f_2$     &  \compN &  \compY &  \compY     &  \compY     &  \compN     & \compN  & \compN  & \compN      & \compN      \\ 
\textbf{A}  &  \compY &  \compY &  \compY     &  \compY     &  \compN     & \compY  & \compY  & \compY      & \compY      \\
\textbf{B}  &  \compY &  \compY &  \compY     &  \compY     &  \compY     & \compY  & \compY  & \compY      & \compY      \\ 
\textbf{N}  &  \compN &  \compN &  \compN     &  \compY     &  \compY     & \compN  & \compN  & \compN      & \compY      \\ \hline \hline
$f_1$+      &  \compN &  \compN &  \compY     &  \compY     &  \compN     & \compY  & \compN  & \compY      & \compY      \\ 
$f_2$+      &  \compN &  \compN &  \compY     &  \compY     &  \compN     & \compN  & \compY  & \compY      & \compY      \\ 
\textbf{A}+ &  \compN &  \compN &  \compY     &  \compY     &  \compN     & \compY  & \compY  & \compY      & \compY      \\
\textbf{B}+ &  \compN &  \compN &  \compY     &  \compY     &  \compY     & \compY  & \compY  & \compY      & \compY      \\ \hline
  \end{tabular}
\end{center}\end{table}

To go with this table we present its corresponding Scala matching code in Listing \ref{lst:extuni}.
Unfortunately the steep increase in table size results in the amount of code required exploding.
It also becomes impossible to use our earlier trick of Set matching; due to the need for parametrised
Fingerprint symbols (i.e. A+ and B+; represented as FPA(true) and FPB(true) ).
\begin{listing}[H]
\begin{scalacode}
 /** Check two Fingerprint features for compatibility based
   * on the *extended* unification table (See table in report).*/
  def compareFeaturesForUnification (a:FPFeature, b:FPFeature) : Boolean = 
  (a,b) match {
    case (FPF(a), FPF(b))    => (a.op == b.op) && 
                                (if (a.isFG || b.isFG) 
                                    (!a.isPureBG && !b.isPureBG)
                                 else true)
    case (FPF(t), FPB(true)) => t.isPureBG
    case (FPB(true), FPF(t)) => t.isPureBG
    case (_, FPB(_))         => true
    case (FPB(_), _)         => true
    case (FPF(t), FPA(true)) => t.isPureBG
    case (FPA(true), FPF(t)) => t.isPureBG
    case (FPN, FPA(_))       => false
    case (FPA(_), FPN)       => false
    case (_, FPA(_))         => true
    case (FPA(_), _)         => true
    case (FPN, FPN)          => true
    case _                   => false
  }
\end{scalacode}
\caption{Scala code to extract fingerprint features for extended layer matching.}
\label{lst:extuni}
\end{listing}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
